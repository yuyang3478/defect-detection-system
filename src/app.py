# -*- coding: utf-8 -*-# ! /usr/bin/env pythonimport errnoimport shutilimport subprocessimport sysimport timefrom PyQt5 import QtWidgetsfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QtCore import *from PyQt5 import QtGui, QtCorefrom PyQt5.QtWebEngineWidgets import QWebEngineViewfrom PyQt5.QtCore import QUrl, QBuffer, QDataStream, QSharedMemory,QByteArrayfrom PyQt5.Qt import (    Qt, QFont, QApplication, QVBoxLayout,    QLabel, QMenu, QIcon, QGroupBox, QWidget, QPushButton, QSplitter)from PyQt5.QtWidgets import (QApplication, QComboBox, QDialog,        QDialogButtonBox, QFormLayout, QGridLayout, QGroupBox, QHBoxLayout,QInputDialog,        QLabel, QLineEdit, QMenu, QMenuBar, QPushButton, QSpinBox, QTextEdit,        QVBoxLayout)from bash import *from tool import *from augmentation import *from imageviewer import *from  ui_import_dialog import Ui_Dialogif sys.platform.startswith('linux') :    import ctypes    ctypes.CDLL("libGL.so.1", mode=ctypes.RTLD_GLOBAL)import configparserimport pwdimport cv2# import unicodefrom multiprocessing import Process,Managerimport os, stringimport mathTHUMB_WIDTH = 128*2THUMB_HEIGHT = 128*2THUMB_MIN = 64THUMB_MAX = 256*2FILE_TYPE = ['jpg', 'jpeg', 'tif', 'bmp', 'gif','png']max_show = 100# TODO: about menu add 人工智能第一代产品及相关功能简介class ImageWidget(QWidget):    # 单选,上一个被选择的对象    prevSelected = None    """    Use this widget to display image.    """    def __init__(self):        super(ImageWidget, self).__init__()        self.id = 0        self.displayText = ''  # 显示的文字        self.version = ''        self.status = 0        self.path = ''        self.showStatus = True        self.selected = False        self.isHightlight = False        self.thumb = QImage()        self.initAttrib()    def initAttrib(self):        self.name_font = QFont()        self.bg_color = QColor(50, 50, 50)        self.hightlight = QColor(255, 255, 255, 100)        self.edge_size = 4        self.pen_selected = QPen(QColor(255, 255, 0))        self.pen_selected.setWidth(self.edge_size)        self.pen_selected.setJoinStyle(QtCore.Qt.MiterJoin)    #        self.setToolTip('aaaa\nbbbb\ncccc')    def assetFile(self):        return self.path + "_asset_.txt"    def thumbFile(self):        return self.path + "_thumb_.png"    def informationFile(self):        return self.path + "_information_.txt"    def getPublishPath(self):        current_version = self.version        if not current_version:            current_version = '000'        new_version = int(string.atof(current_version)) + 1        return '%s/%03d' % (self.path, new_version)    def getVersionPath(self, version):        return '%s/%s' % (self.path, version)    def getCurrentVersionPath(self):        return self.getVersionPath(self.version)    def setThumb(self, thumb=None):        self.path = thumb        if not thumb:            thumb = self.thumbFile()        if os.path.isfile(thumb):            if thumb.endswith("png"):                cv_img = cv2.imread(thumb)*255                 # Notice the dimensions.                height, width, bytesPerComponent = cv_img.shape                bytesPerLine = bytesPerComponent * width;                # Convert to RGB for QImage.                cv2.cvtColor(cv_img, cv2.COLOR_BGR2RGB, cv_img)                self.thumb = QImage(cv_img.data, width, height, bytesPerLine, QImage.Format_RGB888)            else:                self.thumb.load(thumb)#QtCore.QString(thumb))            self.repaint()            return True    def paintAsThumb(self, painter):        name_height = max(self.height() * 0.10, 15)        name_ty = self.height() - self.edge_size * 2        # draw background        painter.fillRect(self.rect(), self.bg_color)        painter.drawImage(self.rect(), self.thumb)        # draw hightlight        if self.isHightlight and not self.selected:            painter.fillRect(self.rect(), self.hightlight)        # draw name        painter.setPen(QPen(QColor(255, 255, 255)))        self.name_font.setPixelSize(name_height)        painter.setFont(self.name_font)        # 脚标字符        painter.drawText(self.edge_size, name_ty, str(self.displayText))        if self.status:            title_height = self.edge_size + name_height            p1 = QtCore.QPoint(0, 0)            p2 = QtCore.QPoint(0, title_height)            p3 = QtCore.QPoint(title_height, 0)            painter.setPen(QtCore.Qt.NoPen)            painter.fillRect(0, 0, self.width(), title_height, QColor(40, 40, 40, 40))            if self.status == 1:                painter.setBrush(QBrush(QColor(255, 0, 0)))            elif self.status == 2:                painter.setBrush(QBrush(QColor(0, 255, 0)))            elif self.status == 3:                painter.setBrush(QBrush(QColor(0, 0, 255)))            painter.drawConvexPolygon(p1, p2, p3)        if self.version:            version_x = self.width() - self.edge_size - name_height * 1.5            version_y = name_height            painter.setPen(QPen(QColor(255, 255, 255)))            painter.drawText(version_x, version_y, '%s' % self.version)        # draw selected        if self.selected:            painter.setPen(self.pen_selected)            painter.setBrush(QtCore.Qt.NoBrush)            painter.drawRect(self.edge_size / 2, self.edge_size / 2, \                             self.width() - self.edge_size, self.height() - self.edge_size)    def paintEvent(self, event):        painter = QPainter(self)        self.paintAsThumb(painter)    def mouseReleaseEvent(self, event):        if event.button() == QtCore.Qt.LeftButton:            self.setSelected()    def mouseDoubleClickEvent(self, event):        # print("double clicked ")        name = os.path.split(self.path)[1]        image = cv2.imread(self.path)        cv2.namedWindow(name,cv2.WINDOW_AUTOSIZE)        self.screen = QDesktopWidget().screenGeometry()        h,w,_ = image.shape        # print(image.shape)        # self.move((self.screen.width() - self.size.width()) / 2, (self.screen.height() - self.size.height()) / 2)        cv2.moveWindow(name, int((self.screen.width() - w) / 2), int((self.screen.height() - h) / 2))        if name.endswith("png"):            image = image*255        cv2.imshow(name,image)        cv2.waitKey()        cv2.destroyAllWindows()        # imgv = ImageViewer(self.path)        # # imgv.open(self.path)        # imgv.show()        # self.emit(QtCore.SIGNAL('doubleClick'))    def enterEvent(self, event):        self.isHightlight = True        self.repaint()    def leaveEvent(self, event):        self.isHightlight = False        self.repaint()    # 设定当前为选中状态    def setSelected(self):        # 取消其他缩略图的选择状态, 当前设为选择状态        if ImageWidget.prevSelected != None:            ImageWidget.prevSelected.selected = False            ImageWidget.prevSelected.repaint()        self.selected = True        self.repaint()        ImageWidget.prevSelected = self        self.onWidgetClicked()        # self.emit(QtCore.SIGNAL("click"), self.id)    def onWidgetClicked(self):        pass        # print('on widget clicked')class ImageContainer(QWidget):    def __init__(self, widgets=None):        super(ImageContainer, self).__init__()        containerLayout = QVBoxLayout()        # 初始化Slider        self.zoomSlider = QSlider()        self.zoomSlider.setOrientation(QtCore.Qt.Horizontal)        self.zoomSlider.setMinimum(THUMB_MIN)        self.zoomSlider.setMaximum(THUMB_MAX)        self.zoomSlider.setValue(THUMB_WIDTH)        self.zoomSlider.setFixedWidth(128*2)        self.zoomSlider.setFixedHeight(10)        self.zoomSlider.valueChanged[int].connect(self.setItemSize)        # Slider设定        # QtCore.QObject.emit(self.zoomSlider, QtCore.SIGNAL('valueChanged(int)'), self.setItemSize)        self.item_scrollarea = QScrollArea()        self.item_area = QWidget()        self.item_scrollarea.setWidget(self.item_area)        containerLayout.addWidget(self.zoomSlider)        containerLayout.addWidget(self.item_scrollarea)        self.widget_w = THUMB_WIDTH        self.widget_h = THUMB_HEIGHT        self.min_width = THUMB_MIN        self.max_height = THUMB_MAX        self.asset_space = 4        self.auto_space = True        self.setWindowOpacity(0.0)        self.setLayout(containerLayout)        # 缩略图对象列表        self.ImageWidgetList = {}    def addWidget(self, widget):        widget.setParent(self.item_area)        widget.resize(self.widget_w, self.widget_h)        widget.show()        # 添加到列表        self.ImageWidgetList[str(widget.id)] = widget    def addWidgets(self, widgets):        for widget in widgets:            self.addWidget(widget)        self.layout()    def clearAll(self):        widgets = self.item_area.children()        if widgets:            for widget in widgets:                widget.setParent(None)        self.ImageWidgetList.clear()    def layout(self):        w = self.width()# - 20        widgets = self.item_area.children()        num_x = max(math.ceil(w / (self.widget_w + self.asset_space)), 1)-1  # Can do -1        num_y = math.ceil(len(widgets) / num_x)        self.item_area.resize(w-35, num_y * (self.widget_h + self.asset_space))# + 50        main_w = self.item_area.width()        main_h = self.item_area.height()        num_x = max(math.ceil(main_w / (self.widget_w + self.asset_space)), 1)-1  # Can do -1        x = 0        y = 0        for i in range(min(len(widgets),max_show)):#min(len(widgets),max_show)            space_x = 0            if self.auto_space:                space_x = (main_w - self.asset_space * 2 - num_x * (self.widget_w + self.asset_space)) / num_x            widgets[i].move(self.asset_space * 2 + x * (self.widget_w + self.asset_space + space_x), \                            self.asset_space * 2 + y * (self.widget_h + self.asset_space + space_x))            x += 1            if x >= num_x:                x = 0                y += 1    def resizeEvent(self, event):        self.layout()    def changeItemSize(self, mount):        widgets = self.item_area.children()        self.widget_w += mount        if self.widget_w > self.max_height:            self.widget_w = self.max_height        elif self.widget_w < self.min_width:            self.widget_w = self.min_width        self.widget_h += mount        if self.widget_h > self.max_height:            self.widget_h = self.max_height        elif self.widget_h < self.min_width:            self.widget_h = self.min_width        for a in widgets:            a.resize(self.widget_w, self.widget_h)        self.layout()    def setItemSize(self, size):        widgets = self.item_area.children()        self.widget_w = size        self.widget_h = size        for a in widgets:            a.resize(size, size)        self.layout()    # 设定指定id为选中状态    def setSelected(self, id):        print('ImageContainer -> setSelected    ', id)        self.ImageWidgetList[str(id)].setSelected()class MainWindow(QtWidgets.QMainWindow):    MaxRecentFiles = 5    windowList = []    def __init__(self):        app = QApplication(sys.argv)        super(MainWindow, self).__init__()        if "src" in os.getcwd():            os.chdir("..")        # self.setStyleSheet("QMainWindow {background: '#F8F8FF';}")        # self.setStyleSheet("QMainWindow {background: '#F57C00';}")#orange        self.cwd = os.getcwd()        self.src = os.path.join(self.cwd,"src")        self.rootPath = None        self.recentFileActs = []        self.max_show=100        self.setAttribute(Qt.WA_DeleteOnClose)        # self.textEdit = QTextEdit()        # self.setCentralWidget(self.textEdit)        self.statusBar().showMessage('系统初始化完成。')        # self.showFullScreen()        self.showMaximized()        self.setWindowTitle("智能缺陷检测系统")        # self.resize(1280, 800)        # 屏幕居中        self.screen = QDesktopWidget().screenGeometry()        self.size = self.geometry()        self.move((self.screen.width() - self.size.width()) / 2, (self.screen.height() - self.size.height()) / 2)        mainSpliter = QSplitter(QtCore.Qt.Horizontal)        # mainSpliter.setStyleSheet("QMainWindow {background: '#F57C00';}")        # 文件夹列表model        self.dirModel = QDirModel(self)        # self.dirModel = QFileSystemModel(self)        # 只显示文件夹        # self.dirModel.setFilter(QtCore.QDir.Dirs | QtCore.QDir.NoDotAndDotDot)        self.config = configparser.ConfigParser()        self.config.read('config/model.ini')        self.condefaults = self.config.defaults()        datasets_dir = self.config['train']['datasets_dir']        datasets_dir = os.path.join(datasets_dir,"crack")        # 文件夹列表view        self.dirTreeView = QTreeView()        # parent = os.path.join(os.getcwd(), os.pardir)        self.rootPath = os.path.join(pwd.getpwuid(os.getuid()).pw_dir,datasets_dir)##os.path.abspath(parent)#os.getcwd()#"/home/tenghui/"        # self.dirModel.setRootPath("/home/tenghui");        # 绑定model        self.dirTreeView.setModel(self.dirModel)        if self.rootPath is not None:            rootIndex = self.dirModel.index(QDir.cleanPath(self.rootPath))            if rootIndex.isValid():                self.dirTreeView.setRootIndex(rootIndex)                # self.dirTreeView.setRootIndex(self.dirModel.setRootPath("/home/tenghui"))        self.dirTreeView.hideColumn(1)        self.dirTreeView.hideColumn(2)        self.dirTreeView.hideColumn(3)        # DirTree事件响应        self.dirTreeView.selectionModel().selectionChanged.connect(self.dirTreeClicked)        # print(Qt.CustomContextMenu)        self.dirTreeView.setContextMenuPolicy(3)#Qt.CustomContextMenu==3        self.dirTreeView.customContextMenuRequested.connect(self.show_preview_context_menu)        # self.connect(self.dirTreeView,        #              QtCore.SIGNAL("customContextMenuRequested(const QPoint &)"), self.treeViewRightClick)        # # self.dirTreeView.rightClicked.connect(self.treeViewRightClick)        mainLayout = QVBoxLayout()        tab = QtWidgets.QTabWidget()        topLayout = QVBoxLayout()        # self.dirTreeView.setMinimumWidth(self.geometry().width() * 0.1)        mainSpliter.addWidget(self.dirTreeView)        self.imageContainer = ImageContainer(mainSpliter)        #####################################        ## change color        # self.imageContainer.setAutoFillBackground(True);        # p = self.imageContainer.palette()        # p.setColor(self.imageContainer.backgroundRole(), Qt.green)        # self.imageContainer.setPalette(p)        ######################################        #        self.imageContainer.setGeometry(self.imageContainer.geometry().x(), self.imageContainer.geometry().y(), 100, self.imageContainer.geometry().height())        # self.imageContainer.setMinimumWidth(self.geometry().width() * 0.7)        mainSpliter.addWidget(self.imageContainer)        mainSpliter.setStretchFactor(0, 1);        mainSpliter.setStretchFactor(1, 9);        tab.addTab(mainSpliter, "浏览")#------------------------------------<        ###################################################        # tab train config        ####################################################        self.creatTrainGroupBox()        tab.addTab(self.parameterFormGroupBox, "配置")        ###################################################        # tab train viewpage        ####################################################        view = QWebEngineView()        view.load(QUrl("http://127.0.0.1:6006"))        # web.show()        tab.addTab(view, "训练")#----------------<        ###################################################        # tab inference config        ####################################################        # self.creatInferGroupBox()        # tab.addTab(self.inferformGroupBox, "识别 & config")        ###################################################        # tab inference view        ####################################################        mainSpliter3 = QSplitter(QtCore.Qt.Horizontal)        # 文件夹列表model        self.dirModel3 = QDirModel(self)        # self.dirModel3 = QFileSystemModel(self)#new        # 只显示文件夹        self.dirModel3.setFilter(QtCore.QDir.Dirs | QtCore.QDir.NoDotAndDotDot)        # 文件夹列表view        self.dirTreeView3 = QTreeView()        # 绑定model        self.dirTreeView3.setModel(self.dirModel3)        self.dirTreeView3.hideColumn(1)        self.dirTreeView3.hideColumn(2)        self.dirTreeView3.hideColumn(3)        # DirTree事件响应        self.dirTreeView3.selectionModel().selectionChanged.connect(self.dirTreeClicked3)        mainSpliter3.addWidget(self.dirTreeView3)        self.imageContainer3 = ImageContainer(mainSpliter3)        #        self.imageContainer.setGeometry(self.imageContainer.geometry().x(), self.imageContainer.geometry().y(), 100, self.imageContainer.geometry().height())        # self.imageContainer3.setMinimumWidth(self.geometry().width() * 0.8)        mainSpliter3.addWidget(self.imageContainer3)        mainSpliter3.setStretchFactor(0, 1.5);        mainSpliter3.setStretchFactor(1, 8.5);        #功能上可以和文件tab组合，但是从用户角度出发有必要留下来，有凸显、强调作用。        # tab.addTab(mainSpliter3, "检测 & inference")#---------------------------------<        topLayout.addWidget(tab)        mainLayout.addLayout(topLayout)        self.creatFormGroupBox()        mainLayout.addWidget(self.formGroupBox)        mainLayout.setStretchFactor(topLayout, 8)        mainLayout.setStretchFactor(self.formGroupBox, 2)        # mainLayout.addStretch()        # self.setCentralWidget(self.textEdit)        central = QWidget()        central.setLayout(mainLayout);        self.setCentralWidget(central);        # self.setLayout(mainLayout)        self.createActions()        self.createMenus()        # self.statusBar()        self.createToolBars()        self.show()        #检查训练及inference文件夹是否为空，如果为空引导用户导入相应图片        self.init_folder_check()        sys.exit(app.exec_())    def init_folder_check(self):        annotationrawdir = self.config['annotation']['raw']        annotationrawdir = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, annotationrawdir)        inferrawdir = self.config['inference']['images']        inferrawdir = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, inferrawdir)        if self.is_empty_folder(annotationrawdir) and self.is_empty_folder(inferrawdir):            # 两个文件夹都 为空，提示用户导入相关图片            items = ("导入待检测图片", "导入待标注图片")            item, ok = QInputDialog.getItem(self, "导入",                                            "检测到空文件夹", items, 0, False)            if ok and item:                print(item)                if item==items[0]:                    self.import_train_raw()                else:                    self.import_infer()                # self.itemLabel.setText(item)    def is_empty_folder(self,folder):        for f in os.listdir(folder):            if f.endswith("jpg") or f.endswith("png"):                return False        return True    def show_preview_context_menu(self, point):        # print("show_preview_context_menu")        #创建右键菜单        menu=QMenu(self)        #添加右键菜单中的action        root = QFileInfo(__file__).absolutePath()        menu.addAction(self.importAct)        menu.addAction(self.inferAct)        menu.addSeparator()        menu.addAction(self.importTrainRawAct)        menu.addAction(self.openPixelAnnotationAct)        menu.addAction(self.dataAugAct)        menu.addAction(self.convertToTfrecordAct)        menu.addAction(self.trainAct)        menu.addAction(self.exportAct)        menu.addSeparator()        menu.addAction(self.refreshAct)        menu.addAction(self.deleteDirAct)        menu.addAction(self.deleteFileAct)        #显示该菜单，进入消息循环        menu.exec(self.dirTreeView.mapToGlobal(point));    def export_click(self):        # Export the trained checkpoint.        training_number_of_steps = self.config['train']['training_number_of_steps']        ckpt_file = "model.ckpt-"+training_number_of_steps        export_file = "frozen_inference_graph.pb"        work_dir = self.condefaults['work_dir']        work_dir = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, work_dir)        train_logdir = self.config['train']['train_logdir']        train_logdir = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, train_logdir)        checkpoint_file = os.path.join(train_logdir,ckpt_file)        frozen_pb = self.config['inference']['frozen_pb']        frozen_pb = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, frozen_pb)        frozen_pb = os.path.join(frozen_pb,export_file)        model_variant = self.config['train']['model_variant']        # model_variant = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, model_variant)        output_stride = self.config.getint("train","output_stride")        # output_stride = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, output_stride)        crop_size = self.config['train']['train_crop_size']        # crop_size = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, crop_size)        if output_stride == 16:            arlist = [6, 12, 18]        elif output_stride == 8:            arlist = [12, 24, 36]        else:            print("output_stride set error,(8 or 16)")        export_bash = "python " + os.path.join(work_dir, "export_model.py \\\n") + \                      "--logtostderr \\\n" + \                      "--checkpoint_path=" + checkpoint_file + " \\\n" + \                      "--export_path=" + frozen_pb + " \\\n" + \                      "--model_variant=" + model_variant + " \\\n" + \                      "--atrous_rates=" + str(arlist[0]) + " \\\n" + \                      "--atrous_rates=" + str(arlist[1]) + " \\\n" + \                      "--atrous_rates=" + str(arlist[2]) + " \\\n" + \                      "--output_stride=" + str(output_stride) + " \\\n" + \                      "--decoder_output_stride=4 \\\n" + \                      "--num_classes=2 \\\n" + \                      "--crop_size=" + crop_size + " \\\n" + \                      "--crop_size=" + crop_size + " \\\n" + \                      "--inference_scales=1.0"        with open(os.path.join(self.src,"export.sh"),"w") as f:            with open(os.path.join(self.src,"exportinit.sh"),"r") as fr:                lines = fr.readlines()                for line in lines:                    f.write(line)            f.write(export_bash)        self.exportbash = Bash()        self.exportbash.excute(os.path.join(self.src,"export.sh"))    def infer_click(self):        # pathSelected = self.dirModel.filePath(self.dirTreeView.selectedIndexes()[0])        # if len(pathSelected)==0:        #     self.status("Please select a directory.")        #     return        #        # with open(os.path.join(self.src,"inference.sh"),"w") as f:        #     f.write("\n")        self.inferencebash = Bash()        self.inferencebash.excute(os.path.join(self.src,"inference.sh"))        print("开始检测，请手动刷新 exp/vis 文件夹。")    def delete_dir(self):        if len(self.dirTreeView.selectedIndexes())==0:            QMessageBox.information(self,  # 使用infomation信息框                                    "错误",                                    "请选择要删除的文件夹。",                                    QMessageBox.Yes)            # self.status("Please select a folder to delete.")            return        # 获取选择的路径        pathSelected = self.dirModel.filePath(self.dirTreeView.selectedIndexes()[0])        if os.path.isfile(pathSelected):            QMessageBox.information(self,  # 使用infomation信息框                                    "错误",                                    "已选中文件，请重新选择要删除的文件夹。",                                    QMessageBox.Yes)        elif os.path.isdir(pathSelected):            shutil.rmtree(pathSelected)            print('删除   ', os.path.split(pathSelected)[1])        self.dirModel.refresh()        self.imageContainer.layout()        # 遍历路径下的媒体文件        # for item in os.listdir(pathSelected):        #     if item.split('.')[-1] in FILE_TYPE:        #         print(item)    def delete_files(self):        if len(self.dirTreeView.selectedIndexes())==0:            QMessageBox.information(self,  # 使用infomation信息框                                    "错误",                                    "先选择文件夹，才能删除文件夹下的所有文件.",                                    QMessageBox.Yes)            return        pathSelected = self.dirModel.filePath(self.dirTreeView.selectedIndexes()[0])        if os.path.isfile(pathSelected):            os.remove(pathSelected)        elif os.path.isdir(pathSelected):            for f in os.listdir(pathSelected):                path = os.path.join(pathSelected,f)                if os.path.isfile(path):                    os.remove(path)                else:                    shutil.rmtree(path)                self.dirModel.refresh()                self.imageContainer.clearAll()                print('删除文件： ', f)        self.refresh_dir()        self.imageContainer.layout()    def refresh_dir(self):        self.dirModel.refresh()    def creatTrainGroupBox(self):        self.trainformGroupBox = QGroupBox("train parameters")        layout = QFormLayout()        training_number_of_steps_label=QLabel("iteration number")        self.training_number_of_steps_editor = QLineEdit(self.config['train']['training_number_of_steps'])        train_crop_size_label=QLabel("crop size")        self.train_crop_size_editor= QLineEdit(self.config['train']['train_crop_size'])        train_batch_size_label=QLabel("batch size")        self.train_batch_size_editor=QLineEdit(self.config['train']['train_batch_size'])        model_variant_label=QLabel("model")        self.model_variant_editor=QLineEdit(self.config['train']['model_variant'])        output_stride_label=QLabel("output variant")        self.output_stride_editor=QLineEdit(self.config['train']['output_stride'])        log_steps_label=QLabel("log steps")        self.log_steps_editor=QLineEdit(self.config['train']['log_steps'])        save_interval_secs_lable=QLabel("save interval secs")        self.save_interval_secs_editor = QLineEdit(self.config['train']['save_interval_secs'])        save_summaries_secs_lable=QLabel("save summaries secs")        self.save_summaries_secs_editor=QLineEdit(self.config['train']['save_summaries_secs'])        base_learning_rate_label=QLabel("base learning rate")        self.base_learning_rate_editor=QLineEdit(self.config['train']['base_learning_rate'])        learning_rate_decay_step_label=QLabel("learning rate decay step")        self.learning_rate_decay_step_editor=QLineEdit(self.config['train']['learning_rate_decay_step'])        weight_decay_label=QLabel("weight decay")        self.weight_decay_editor=QLineEdit(self.config['train']['weight_decay'])        min_scale_factor_label=QLabel("min scale factor")        self.min_scale_factor_editor=QLineEdit(self.config['train']['min_scale_factor'])        max_scale_factor_label=QLabel("max scale factor")        self.max_scale_factor_editor=QLineEdit(self.config['train']['max_scale_factor'])        scale_factor_step_size_label=QLabel("scale factor step size")        self.scale_factor_step_size_editor=QLineEdit(self.config['train']['scale_factor_step_size'])        layout.addRow(training_number_of_steps_label,self.training_number_of_steps_editor)        layout.addRow(train_crop_size_label, self.train_crop_size_editor)        layout.addRow(train_batch_size_label, self.train_batch_size_editor)        layout.addRow(model_variant_label, self.model_variant_editor)        layout.addRow(output_stride_label, self.output_stride_editor)        layout.addRow(log_steps_label, self.log_steps_editor)        layout.addRow(save_interval_secs_lable, self.save_interval_secs_editor)        layout.addRow(save_summaries_secs_lable, self.save_summaries_secs_editor)        layout.addRow(base_learning_rate_label, self.base_learning_rate_editor)        layout.addRow(learning_rate_decay_step_label, self.learning_rate_decay_step_editor)        layout.addRow(weight_decay_label, self.weight_decay_editor)        layout.addRow(min_scale_factor_label, self.min_scale_factor_editor)        layout.addRow(max_scale_factor_label, self.max_scale_factor_editor)        layout.addRow(scale_factor_step_size_label, self.scale_factor_step_size_editor)        savebutton = QPushButton("save", self)        savebutton.setToolTip("保存所有训练参数")        savebutton.clicked.connect(self.save_click)        clearbutton = QPushButton("stop", self)        clearbutton.setToolTip("清空所有参数")        clearbutton.clicked.connect(self.stop_click)        trainbutton = QPushButton("start", self)        trainbutton.setToolTip("清空所有参数")        trainbutton.clicked.connect(self.train_click)        hbox = QHBoxLayout()        hbox.addStretch(1)        hbox.addWidget(savebutton)        hbox.addWidget(trainbutton)        hbox.addWidget(clearbutton)        vbox = QVBoxLayout()        vbox.addStretch(1)        vbox.addLayout(hbox)        layout.addRow(vbox)        self.trainformGroupBox.setLayout(layout)        IMAGE_FOLDER = "${PASCAL_ROOT}/JPEGImages"        LIST_FOLDER = "${PASCAL_ROOT}/ImageSets/Segmentation"        # echo        # "Converting PASCAL VOC 2012 dataset..."        # python. / build_voc2012_data.py \        #     --image_folder = "${IMAGE_FOLDER}" \        #     --semantic_segmentation_folder = "${SEMANTIC_SEG_FOLDER}" \        #     --list_folder = "${LIST_FOLDER}" \        #     --image_format = "jpg" \        #     --output_dir = "${OUTPUT_DIR}"        # work_dir = self.condefaults['work_dir']        # work_dir = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, work_dir)        self.recordFormGroupBox = QGroupBox("convert record parameter")        recordlayout = QFormLayout()        recordImgFolderLabel = QLabel("image folder：")        self.recordImgFolderEditor = QLineEdit(os.path.join(self.config['convert']['imganno_dir'],"JPEGImages"))        recordSegmentationFolderLabel = QLabel("semantic segmentation folder：")        recordSegmentationFolderEditor = QLineEdit(os.path.join(self.config['convert']['imganno_dir'],"SegmentationClassRaw"))        recordListFolderLabel = QLabel("list folder")        recordListFolderEditor = QLineEdit(os.path.join(self.config['convert']['imganno_dir'],"ImageSets/Segmentation"))        recordOutputFolderLabel = QLabel("output dir")        self.recordOutputFolderEditor = QLineEdit(self.config['convert']['tf_record_dir'])        recordlayout.addRow(recordImgFolderLabel,self.recordImgFolderEditor)        recordlayout.addRow(recordSegmentationFolderLabel, recordSegmentationFolderEditor)        recordlayout.addRow(recordListFolderLabel, recordListFolderEditor)        recordlayout.addRow(recordOutputFolderLabel, self.recordOutputFolderEditor)        rsavebutton = QPushButton("保存", self)        rsavebutton.setToolTip("保存")        rsavebutton.clicked.connect(self.tfrecord_save_click)        rclearbutton = QPushButton("清空", self)        rclearbutton.setToolTip("清空")        rclearbutton.clicked.connect(self.tfrecord_stop_click)        rtrainbutton = QPushButton("转换", self)        rtrainbutton.setToolTip("转换")        rtrainbutton.clicked.connect(self.tfrecord_convert_click)        rhbox = QHBoxLayout()        rhbox.addStretch(1)        rhbox.addWidget(rsavebutton)        # hbox.addWidget(clearbutton)        rhbox.addWidget(rtrainbutton)        rhbox.addWidget(rclearbutton)        rvbox = QVBoxLayout()        rvbox.addStretch(1)        rvbox.addLayout(rhbox)        # layout.addRow(rvbox)        recordlayout.addRow(rvbox)        self.recordFormGroupBox.setLayout(recordlayout)        # self.infereceFormGroupBox = QGroupBox("inference parameter")        # inferecelayout = QFormLayout()        # infereceperformanceLabel = QLabel("性能特点：")        # infereceperformanceEditor = QLineEdit("舱内设计更宜居方便天宫生活")        # infereceplanLabel = QLabel("发射规划：")        # infereceplanEditor = QTextEdit()        # infereceplanEditor.setPlainText("2020年之前，中国计划初步完成空间站建设")        # inferecelayout.addRow(infereceperformanceLabel, infereceperformanceEditor)        # inferecelayout.addRow(infereceplanLabel, infereceplanEditor)        # self.infereceFormGroupBox.setLayout(inferecelayout)        leftgbox = QGroupBox("")        llayout = QVBoxLayout()        infergbox = QGroupBox("inference parameter")        inferlayout = QFormLayout()        vis_crop_sizeLabel = QLabel("vis crop size")        self.vis_crop_sizeEditor = QLineEdit(self.config['inference']['vis_crop_size'])        vis_logdirLabel = QLabel("vis logdir")        self.vis_logdirEditor = QLineEdit(self.config['inference']['vis_logdir'])        inferlayout.addRow(vis_crop_sizeLabel, self.vis_crop_sizeEditor)        inferlayout.addRow(vis_logdirLabel, self.vis_logdirEditor)        isavebutton = QPushButton("save", self)        isavebutton.setToolTip("保存")        isavebutton.clicked.connect(self.infer_save_click)        iclearbutton = QPushButton("stop", self)        iclearbutton.setToolTip("终止")        iclearbutton.clicked.connect(self.infer_stop_click)        itrainbutton = QPushButton("start", self)        itrainbutton.setToolTip("转换")        itrainbutton.clicked.connect(self.infer_click)        ihbox = QHBoxLayout()        ihbox.addStretch(1)        ihbox.addWidget(isavebutton)        # hbox.addWidget(clearbutton)        ihbox.addWidget(itrainbutton)        ihbox.addWidget(iclearbutton)        ivbox = QVBoxLayout()        # ivbox.addStretch(1)        ivbox.addLayout(ihbox)        # layout.addRow(rvbox)        inferlayout.addRow(ivbox)        infergbox.setLayout(inferlayout)        tensorgbox = QGroupBox("tensorboard")        tensorlayout = QFormLayout()        tsavebutton = QPushButton("start", self)        tsavebutton.setToolTip("开始")        tsavebutton.clicked.connect(self.tensorboard_start_click)        tclearbutton = QPushButton("stop", self)        tclearbutton.setToolTip("终止")        tclearbutton.clicked.connect(self.tensorboard_stop_click)        thbox = QHBoxLayout()        thbox.addStretch(1)        thbox.addWidget(tsavebutton)        thbox.addWidget(tclearbutton)        tvbox = QVBoxLayout()        # tvbox.addStretch(1)        tvbox.addLayout(thbox)        # layout.addRow(rvbox)        tensorlayout.addRow(tvbox)        tensorgbox.setLayout(tensorlayout)        llayout.addWidget(self.recordFormGroupBox)        llayout.addWidget(infergbox)        llayout.addWidget(tensorgbox)        leftgbox.setLayout(llayout)        parameterhboxLayout = QHBoxLayout()        parameterhboxLayout.addWidget(leftgbox)        parameterhboxLayout.addWidget(self.trainformGroupBox)        self.parameterFormGroupBox = QGroupBox("super parameter settings")        self.parameterFormGroupBox.setLayout(parameterhboxLayout)    def tensorboard_start_click(self):        subprocess.Popen("tensorboard --logdir="+os.path.join(pwd.getpwuid(os.getuid()).pw_dir, self.config['train']['train_logdir']), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)        print("tensorboard started at localhost:6006.")    def tensorboard_stop_click(self):        subprocess.Popen("pkill -9 tensorboard", shell=True,                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)        print("tensorboard has been terminated.")    def infer_save_click(self):        self.config.set("inference", "vis_crop_size", self.vis_crop_sizeEditor.text())        self.config.set("inference", "vis_logdir", self.vis_logdirEditor.text())        self.config.write(open("config/model.ini", "w"))        print("inference parameters saved!")    def infer_stop_click(self):        self.inferencebash.kill()    def tfrecord_save_click(self):        # print( self.recordOutputFolderEditor.text())        imgannodir = os.path.split(self.recordImgFolderEditor.text())[0]        self.config.set("convert", "imganno_dir", imgannodir)        self.config.set("convert", "tf_record_dir", self.recordOutputFolderEditor.text())        self.config.write(open("config/model.ini", "w"))        # print(self.training_number_of_steps_editor.text())        print("convert parameters saved!")    def tfrecord_stop_click(self):        self.convertbash.kill()    def tfrecord_convert_click(self):        datasets_dir = self.config['DEFAULT']['datasets_dir']        datasets_dir = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, datasets_dir)        image_folder = os.path.join(self.config['convert']['imganno_dir'], "JPEGImages")        image_folder = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, image_folder)        semantic_segmentation_folder = os.path.join(self.config['convert']['imganno_dir'], "SegmentationClassRaw")        semantic_segmentation_folder = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, semantic_segmentation_folder)        list_folder = os.path.join(self.config['convert']['imganno_dir'], "ImageSets/Segmentation")        list_folder = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, list_folder)        output_dir = os.path.join(self.config['convert']['tf_record_dir'])        output_dir = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, output_dir)        convert_bash = "python build_voc2012_data.py \\\n" + \                     "--image_folder="+image_folder+" \\\n" + \                     "--semantic_segmentation_folder="+semantic_segmentation_folder+" \\\n" + \                     "--list_folder=" + list_folder + " \\\n" + \                     "--image_format=jpg \\\n" + \                     "--output_dir=" + output_dir                     # work_dir = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, work_dir)        with open(os.path.join(self.src,"convert.sh"),"w") as f:            with open(os.path.join(self.src,"convertinit.sh"),"r") as fr:                lines = fr.readlines()                for line in lines:                    f.write(line)            f.write(convert_bash)        # sub = subprocess.Popen('bash convert.sh', shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)        # stdout, stderr = sub.communicate()        # exit_code = sub.returncode        # print(exit_code)        # print(stdout.decode('utf-8'), stderr.decode('utf-8'))        self.convertbash = Bash()        self.convertbash.excute(os.path.join(self.src,"convert.sh"))    def stop_click(self):        self.trainbash.kill()    def train_click(self):        # self.config = configparser.ConfigParser()        # self.config.read('config/model.ini')        model_variant = self.config['train']['model_variant']        output_stride = self.config['train']['output_stride']        train_crop_size = self.config['train']['train_crop_size']        train_batch_size = self.config['train']['train_batch_size']        training_number_of_steps = self.config['train']['training_number_of_steps']        fine_tune_batch_norm = self.config['train']['fine_tune_batch_norm']        work_dir = self.condefaults['work_dir']        work_dir = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, work_dir)        tf_initial_checkpoint = self.config['train']['tf_initial_checkpoint']        tf_initial_checkpoint = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, tf_initial_checkpoint)        train_logdir = self.config['train']['train_logdir']        train_logdir = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, train_logdir)        tf_record_dir = self.config['convert']['tf_record_dir']        tf_record_dir = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, tf_record_dir)        log_steps = self.config['train']['log_steps']        save_interval_secs = self.config['train']['save_interval_secs']        save_summaries_secs = self.config['train']['save_summaries_secs']        learning_rate_decay_step = self.config['train']['learning_rate_decay_step']        weight_decay = self.config['train']['weight_decay']        min_scale_factor = self.config['train']['min_scale_factor']        max_scale_factor = self.config['train']['max_scale_factor']        scale_factor_step_size = self.config['train']['scale_factor_step_size']        # train_batch_size = self.config['train']['train_crop_size']        intos = int(output_stride)        if intos ==16:            arlist = [6,12,18]        elif intos==8:            arlist = [12,24,36]        else:            print("output_stride set error,(8 or 16)")        # work_dir = os.path.join(pwd.getpwuid(os.getuid()).pw_dir,work_dir)        cd_bash = "cd "+work_dir        train_bash = "python "+os.path.join(work_dir,"train.py \\\n")+ \                     "--logtostderr \\\n"+ \                     "--train_split=train \\\n"+ \                     "--model_variant="+model_variant+" \\\n"+\                     "--atrous_rates="+str(arlist[0])+" \\\n"+ \                     "--atrous_rates="+str(arlist[1])+" \\\n" + \                     "--atrous_rates="+str(arlist[2])+" \\\n" + \                     "--output_stride="+output_stride+" \\\n" + \                     "--decoder_output_stride=4 \\\n" + \                     "--train_crop_size="+train_crop_size+" \\\n"+\                     "--train_crop_size="+train_crop_size+" \\\n" + \                     "--train_batch_size="+train_batch_size+" \\\n" + \                     "--training_number_of_steps="+training_number_of_steps+" \\\n" + \                     "--fine_tune_batch_norm="+fine_tune_batch_norm+" \\\n" + \                     "--log_steps=" + log_steps + " \\\n" + \                     "--save_interval_secs=" + save_interval_secs + " \\\n" + \                     "--save_summaries_secs=" + save_summaries_secs + " \\\n" + \                     "--learning_rate_decay_step=" + learning_rate_decay_step + " \\\n" + \                     "--weight_decay=" + weight_decay + " \\\n" + \                     "--min_scale_factor=" + min_scale_factor + " \\\n" + \                     "--max_scale_factor=" + max_scale_factor + " \\\n" + \                     "--scale_factor_step_size=" + scale_factor_step_size+" \\\n" + \                     "--tf_initial_checkpoint="+tf_initial_checkpoint+" \\\n" + \                     "--train_logdir="+train_logdir+" \\\n" + \                     "--dataset_dir="+tf_record_dir        with open(os.path.join(self.src,"train.sh"),"w") as f:            with open(os.path.join(self.src,"traininit.sh"),"r") as fr:                lines = fr.readlines()                for line in lines:                    f.write(line)            f.write(train_bash)        self.trainbash = Bash()        self.trainbash.excute(os.path.join(self.src,"train.sh"))        # sub = subprocess.Popen('bash train.sh', shell=True, stdout=subprocess.PIPE)        # join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。        # p.join()        # os.popen(train_bash).read().strip()        #session_config.gpu_options.per_process_gpu_memory_fraction=0.7    # def excute_train(self):    #     print(os.popen("bash tmp.sh").read().strip())    def save_click(self):        # self.config = configparser.ConfigParser()        # self.config.read('config/model.ini')        # imganno_dir = self.config['train']['imganno_dir']        self.config.set("train", "training_number_of_steps", self.training_number_of_steps_editor.text())        self.config.set("train", "train_crop_size", self.train_crop_size_editor.text())        self.config.set("train", "train_batch_size", self.train_batch_size_editor.text())        self.config.set("train", "model_variant", self.model_variant_editor.text())        self.config.set("train", "output_stride", self.output_stride_editor.text())        self.config.set("train", "log_steps", self.log_steps_editor.text())        self.config.set("train", "save_interval_secs", self.save_interval_secs_editor.text())        self.config.set("train", "save_summaries_secs", self.save_summaries_secs_editor.text())        self.config.set("train", "base_learning_rate", self.base_learning_rate_editor.text())        self.config.set("train", "learning_rate_decay_step", self.learning_rate_decay_step_editor.text())        self.config.set("train", "weight_decay", self.weight_decay_editor.text())        self.config.set("train", "min_scale_factor", self.min_scale_factor_editor.text())        self.config.set("train", "max_scale_factor", self.max_scale_factor_editor.text())        self.config.set("train", "scale_factor_step_size", self.scale_factor_step_size_editor.text())        self.config.write(open("config/model.ini", "w"))        # print(self.training_number_of_steps_editor.text())        print("parameters saved!")    # def creatInferGroupBox(self):    #     self.inferformGroupBox = QGroupBox("超参数设置")    #     layout = QFormLayout()    #     performanceLabel = QLabel("性能特点：")    #     performanceEditor = QLineEdit("舱内设计更宜居方便天宫生活")    #     planLabel = QLabel("发射规划：")    #     planEditor = QTextEdit()    #     planEditor.setPlainText("2020年之前，中国计划初步完成空间站建设")    #     layout.addRow(performanceLabel,performanceEditor)    #     layout.addRow(planLabel,planEditor)    #    #     self.inferformGroupBox.setLayout(layout)    def creatFormGroupBox(self):        self.formGroupBox = QGroupBox("信息:")        layout = QVBoxLayout()#QFormLayout()        # performanceLabel = QLabel("性能特点：")        # performanceEditor = QLineEdit("舱内设计更宜居方便天宫生活")        self.consoleEditor = QTextEdit()        # self.consoleEditor = QtWidgets.QTextEdit(self.scrollAreaWidgetContents_2)        self.consoleEditor.setReadOnly(True)        # self.consoleEditor.setPlainText("2020年之前，中国计划初步完成空间站建设")        # 下面将输出重定向到textEdit中        sys.stdout = EmittingStream(textWritten=self.outputWritten)        sys.stderr = EmittingStream(textWritten=self.outputWritten)        # layout.addRow(performanceLabel,performanceEditor)        layout.addWidget(self.consoleEditor)#addRow(self.consoleEditor)#self.info_title,        self.formGroupBox.setLayout(layout)        # print("2020年之前，中国计划初步完成空间站建设")    # 接收信号str的信号槽    def outputWritten(self, text):        cursor = self.consoleEditor.textCursor()        cursor.movePosition(QtGui.QTextCursor.End)        cursor.insertText(text)        self.consoleEditor.setTextCursor(cursor)        self.consoleEditor.ensureCursorVisible()    def dirTreeClicked3(self):        print('dirTreeClicked')        self.imageContainer3.clearAll()        # 获取选择的路径        pathSelected = self.dirModel3.filePath(self.dirTreeView3.selectedIndexes()[0])        # print('pathSelected   ', pathSelected)        # 遍历路径下的媒体文件        for item in os.listdir(pathSelected):            if item.split('.')[-1] in FILE_TYPE:                # print(item)                # 添加widget                try:                    widget = ImageWidget()                    widget.displayText = item                    widget.setThumb(str(pathSelected + '/' + item))                    self.imageContainer3.addWidget(widget)                except Exception as e:                    print("dirTreeClicked3",e)                    pass        self.imageContainer3.layout()    def treeViewRightClick(self):        print("treeViewRightClick")    def show_images(self,previewPathSelected):        self.imageContainer.clearAll()        # 获取选择的路径        # self.previewPathSelected = self.dirModel.filePath(self.dirTreeView.selectedIndexes()[0])        # print('pathSelected   ', self.previewPathSelected)        if os.path.isfile(previewPathSelected):            item = previewPathSelected            try:                if item.split('.')[-1] in FILE_TYPE:                    widget = ImageWidget()                    widget.displayText = item                    widget.setThumb(str(previewPathSelected))                    self.imageContainer.addWidget(widget)            except Exception as e:                print("add image widget error: ", e)        else:            index =0            # 遍历路径下的媒体文件            for item in os.listdir(previewPathSelected):                if item.split('.')[-1] in FILE_TYPE:                    if index > max_show:                        continue                    index+=1                    # 添加widget                    try:                        widget = ImageWidget()                        widget.displayText = item                        widget.setThumb(str(previewPathSelected + '/' + item))                        self.imageContainer.addWidget(widget)                    except Exception as e:                        print("add image widget error: " , e)        self.imageContainer.layout()    def dirTreeClicked(self):        # print('dirTreeClicked')        previewPathSelected = self.dirModel.filePath(self.dirTreeView.selectedIndexes()[0])        self.show_images(previewPathSelected)    def status(self,message):        self.statusBar().showMessage(message, 2000)    #########################################    # menu releated    ##########################################    def import_images(self,tardir=""):        if len(tardir)==0:            #右键文件夹方式导入            if len(self.dirTreeView.selectedIndexes())==0:                self.statusBar().showMessage("取消选择.", 2000)                return            tardir = self.dirModel.filePath(self.dirTreeView.selectedIndexes()[0])        self.dir = QFileDialog.getExistingDirectory(self, "文件夹", ".")        if not self.dir == '':            try:                # tardir = os.path.join(self.imganno_dir, dirname)                print("拷贝",os.path.split(self.dir)[1],"中文件到",os.path.split(tardir)[1])                for df in os.listdir(self.dir):                    if os.path.isfile(os.path.join(self.dir,df)):                        sourceF = os.path.join(self.dir, df)                        targetF = os.path.join(tardir, df)                    if (sourceF.endswith("png") or sourceF.endswith("jpg")):                        # 文件不存在,或者存在但是大小不同,覆盖                        if not os.path.exists(targetF) or (                                    os.path.exists(targetF) and (                                    os.path.getsize(targetF) != os.path.getsize(sourceF))):                            # 2进制文件                            # open(targetF, "wb").write(open(sourceF, "rb").read())                            img = cv2.imread(sourceF)                            cv2.imwrite(targetF, img)                            print(u"%s %s 复制完成" % (                            time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())), df))                        else:                            print(u"%s %s 已存在,不重复复制" % (                            time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())), df))                        continue            except OSError as exc:  # python >2.5                if exc.errno == errno.ENOTDIR:                    shutil.copy(self.dir, tardir)                else:                    raise            self.dirModel.refresh()            self.show_images(tardir)    def import_train_raw(self):        # self.dir = QFileDialog.getExistingDirectory(self,"文件夹",".")        # if len(self.dirTreeView.selectedIndexes())==0:            # self.statusBar().showMessage("取消选择.", 2000)            # return        # tardir = self.dirModel.filePath(self.dirTreeView.selectedIndexes()[0])        tardir = self.config['annotation']['raw']        tardir = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, tardir)        self.import_images(tardir)    def import_infer(self):        tardir = self.config['inference']['images']        tardir = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, tardir)        self.import_images(tardir)    def data_augmentation(self):        # print("data augmentation action")        self.augbash = Bash()        self.augbash.excute(os.path.join(self.src, "augmentation.sh"))        # pdata = DataAug()        # pdata.aug_img()        # pdata.write_txt()    def newConfig(self):        print("create a new config file")        self.statusBar().showMessage("create a new config file", 2000)    # def import_train(self):    #     self.dir = QFileDialog.getExistingDirectory(self, "文件夹", ".")    #     self.imganno_dir = os.path.join(pwd.getpwuid(os.getuid()).pw_dir,self.config['convert']['imganno_dir'])    #    #     dirname = os.path.split(self.dir)[1]    #     if not self.dir == '':    #         # tardir = os.path.join(self.imganno_dir, "data/inference")    #         # if not os.path.exists(tardir):    #         #     os.makedirs(tardir)    #         try:    #             tardir = os.path.join(self.imganno_dir, dirname)    #             print("coping ", self.dir, " to ", tardir)    #             shutil.copytree(self.dir, tardir)    #         except OSError as exc:  # python >2.5    #             if exc.errno == errno.ENOTDIR:    #                 shutil.copy(self.dir, tardir)    #             else:    #                 raise    #         self.dirModel.refresh()    def openPixelAnnotation(self):        # self.cwd = os.getcwd()#QFileInfo(__file__).absolutePath()        ptdir = os.path.join(self.cwd,"annotation")#,"PixelAnnotationTool"        self.annoBash = Bash()        self.annoBash.excutecmd("cd "+ptdir+" && ./PixelAnnotationTool")        self.statusBar().showMessage("Open Pixel Annotation tool", 2000)    def save(self):        pass        # if self.curFile:        #     self.saveFile(self.curFile)        # else:        #     self.saveAs()    def saveAs(self):        pass        # fileName, _ = QFileDialog.getSaveFileName(self)        # if fileName:        #     self.saveFile(fileName)    def openRecentFile(self):        action = self.sender()        if action:            self.loadFile(action.data())    def about(self):        QMessageBox.about(self, "About Crack Detection System",                          "The <b>Crack Detection System</b> is a deeplearning based tool for detecting various cracks."                          "It can achieve higher accuracy compare to other traditional methods,"                          "and can improve further in the future.")    def createActions(self):        root = QFileInfo(__file__).absolutePath()        self.newAct = QAction(QIcon(root + '/images/new.png'), "&New", self,                              shortcut=QKeySequence.New, statusTip="Create a new config file.",                              triggered=self.newConfig)        # self.importAct = QAction(QIcon(root + '/images/open.png'), "&Import", self,        #                       statusTip="Inport Data", triggered=self.import_infer)        self.saveAct = QAction(QIcon(root + '/images/save.png'), "&Save", self, shortcut=QKeySequence.Save,                               statusTip="Save the document to disk", triggered=self.save)        self.saveAsAct = QAction("Save &As...", self,                                 shortcut=QKeySequence.SaveAs,                                 statusTip="Save the document under a new name",                                 triggered=self.saveAs)        # self.convertToTfrecordAct = QAction("To &TFrecord", self,        #                          statusTip="convert images and annotations to tf record format",        #                          triggered=self.tfrecord_convert_click)        self.openPixelAnnotationAct = QAction(QIcon(root + '/images/annotation.png'),"&数据标注", self,                                              statusTip="open Annotation tool.",                                 triggered=self.openPixelAnnotation)        self.importAct = QAction(QIcon(root + '/images/import.png'), '&导入待检图片', self)        self.importAct.setStatusTip('Import folder.')        self.importAct.setChecked(True)        self.importAct.triggered.connect(self.import_infer)        self.importTrainRawAct = QAction(QIcon(root + '/images/import_anno.png'), '&导入待标注图片', self)        self.importTrainRawAct.setStatusTip('Import folder.')        self.importTrainRawAct.setChecked(True)        self.importTrainRawAct.triggered.connect(self.import_train_raw)        self.dataAugAct = QAction(QIcon(root + '/images/augmentation'), '&数据增强', self)        self.dataAugAct.setStatusTip('Augmentation Images.')        self.dataAugAct.setChecked(True)        self.dataAugAct.triggered.connect(self.data_augmentation)        self.convertToTfrecordAct = QAction(QIcon(root + '/images/editredo.png'), '&格式转换', self)        self.convertToTfrecordAct.setStatusTip('convert to tf record format files.')        self.convertToTfrecordAct.setChecked(False)        self.convertToTfrecordAct.triggered.connect(self.tfrecord_convert_click)        self.trainAct = QAction(QIcon(root + '/images/train.png'), '&训练', self)        self.trainAct.setStatusTip('train models.')        self.trainAct.setChecked(False)        self.trainAct.triggered.connect(self.train_click)        self.exportAct = QAction(QIcon(root + '/images/export.png'), '&导出', self)        self.exportAct.setStatusTip('export(frozen) model.')        self.exportAct.setChecked(False)        self.exportAct.triggered.connect(self.export_click)        self.inferAct = QAction(QIcon(root + '/images/inference.png'), '&检测', self)        self.inferAct.setStatusTip('inference start detection.')        self.inferAct.setChecked(False)        self.inferAct.triggered.connect(self.infer_click)        self.refreshAct = QAction(QIcon(root + '/images/refresh.png'), '&刷新', self)        self.refreshAct.setStatusTip('refresh folder.')        self.refreshAct.setChecked(False)        self.refreshAct.triggered.connect(self.refresh_dir)        self.deleteDirAct = QAction(QIcon(root + '/images/delete.png'), '&删除文件夹', self)        self.deleteDirAct.setStatusTip('delete folder.')        self.deleteDirAct.setChecked(False)        self.deleteDirAct.triggered.connect(self.delete_dir)        self.deleteFileAct = QAction(QIcon(root + '/images/document-delete.png'), '&删除文件', self)        self.deleteFileAct.setStatusTip('delete all files in this folder.')        self.deleteFileAct.setChecked(False)        self.deleteFileAct.triggered.connect(self.delete_files)        for i in range(MainWindow.MaxRecentFiles):            self.recentFileActs.append(                QAction(self, visible=False,                        triggered=self.openRecentFile))        self.exitAct = QAction("E&xit", self, shortcut="Ctrl+Q",                               statusTip="Exit the application",                               triggered=QApplication.instance().closeAllWindows)        self.aboutAct = QAction("&产品说明", self,                                statusTip="Show the application's About box",                                triggered=self.about)        self.aboutQtAct = QAction("About &Qt", self,                                  statusTip="Show the Qt library's About box",                                  triggered=QApplication.instance().aboutQt)    def createMenus(self):        self.fileMenu = self.menuBar().addMenu("&文件")        # self.fileMenu.addAction(self.import_train_Act)        self.fileMenu.addAction(self.importAct)        self.fileMenu.addAction(self.importTrainRawAct)        self.separatorAct = self.fileMenu.addSeparator()        self.fileMenu.addSeparator()        self.fileMenu.addAction(self.refreshAct)        self.fileMenu.addAction(self.deleteDirAct)        self.fileMenu.addAction(self.deleteFileAct)        for i in range(MainWindow.MaxRecentFiles):            self.fileMenu.addAction(self.recentFileActs[i])        self.fileMenu.addSeparator()        self.fileMenu.addAction(self.exitAct)        self.updateRecentFileActions()        # self.menuBar().addSeparator()        self.toolMenu = self.menuBar().addMenu("&工具")        self.toolMenu.addAction(self.openPixelAnnotationAct)        self.toolMenu.addAction(self.dataAugAct)        self.toolMenu.addAction(self.convertToTfrecordAct)        self.toolMenu.addAction(self.trainAct)        self.toolMenu.addAction(self.exportAct)        self.toolMenu.addAction(self.inferAct)        self.helpMenu = self.menuBar().addMenu("&关于")        self.helpMenu.addAction(self.aboutAct)        self.helpMenu.addAction(self.aboutQtAct)    def createToolBars(self):        self.detectBar = self.addToolBar("检测")        self.detectBar.addAction(self.importAct)        self.detectBar.addAction(self.inferAct)        self.trainBar = self.addToolBar("训练")        self.trainBar.addAction(self.importTrainRawAct)        self.trainBar.addAction(self.openPixelAnnotationAct)        self.trainBar.addAction(self.dataAugAct)        self.trainBar.addAction(self.convertToTfrecordAct)        self.trainBar.addAction(self.trainAct)        self.trainBar.addAction(self.exportAct)        self.fileBar = self.addToolBar("文件")        self.fileBar.addAction(self.refreshAct)        self.fileBar.addAction(self.deleteDirAct)        self.fileBar.addAction(self.deleteFileAct)    def loadFile(self, fileName):        file = QFile(fileName)        if not file.open(QFile.ReadOnly | QFile.Text):            QMessageBox.warning(self, "Recent Files",                                "Cannot read file %s:\n%s." % (fileName, file.errorString()))            return        instr = QTextStream(file)        QApplication.setOverrideCursor(Qt.WaitCursor)        self.textEdit.setPlainText(instr.readAll())        QApplication.restoreOverrideCursor()        self.setCurrentFile(fileName)        self.statusBar().showMessage("File loaded", 2000)    def saveFile(self, fileName):        file = QFile(fileName)        if not file.open(QFile.WriteOnly | QFile.Text):            QMessageBox.warning(self, "Recent Files",                                "Cannot write file %s:\n%s." % (fileName, file.errorString()))            return        outstr = QTextStream(file)        QApplication.setOverrideCursor(Qt.WaitCursor)        outstr << self.textEdit.toPlainText()        QApplication.restoreOverrideCursor()        self.setCurrentFile(fileName)        self.statusBar().showMessage("File saved", 2000)    def setCurrentFile(self, fileName):        self.curFile = fileName        if self.curFile:            self.setWindowTitle("%s - Recent Files" % self.strippedName(self.curFile))        else:            self.setWindowTitle("Recent Files")        settings = QSettings('Trolltech', 'Recent Files Example')        files = settings.value('recentFileList', [])        try:            files.remove(fileName)        except ValueError:            pass        files.insert(0, fileName)        del files[MainWindow.MaxRecentFiles:]        settings.setValue('recentFileList', files)        for widget in QApplication.topLevelWidgets():            if isinstance(widget, MainWindow):                widget.updateRecentFileActions()    def updateRecentFileActions(self):        settings = QSettings('Trolltech', 'Recent Files Example')        files = settings.value('recentFileList', [])        numRecentFiles = min(len(files), MainWindow.MaxRecentFiles)        for i in range(numRecentFiles):            text = "&%d %s" % (i + 1, self.strippedName(files[i]))            self.recentFileActs[i].setText(text)            self.recentFileActs[i].setData(files[i])            self.recentFileActs[i].setVisible(True)        for j in range(numRecentFiles, MainWindow.MaxRecentFiles):            self.recentFileActs[j].setVisible(False)        self.separatorAct.setVisible((numRecentFiles > 0))    def strippedName(self, fullFileName):        return QFileInfo(fullFileName).fileName()class EmittingStream(QtCore.QObject):    textWritten = QtCore.pyqtSignal(str)  # 定义一个发送str的信号    def write(self, text):        self.textWritten.emit(str(text))def main():    MainWindow()if __name__ == '__main__':    main()